using System;
using System.Collections.Generic;
using System.Linq;
using TheTechIdea.Beep.Utilities;
using TheTechIdea.Beep.DataBase;
using TheTechIdea.Beep.Helpers.DataTypesHelpers;

namespace TheTechIdea.Beep.Helpers.RDBMSHelpers
{
    /// <summary>
    /// Helper class for generating SQL queries for creating tables, indexes, and other database objects.
    /// </summary>
    public static class DatabaseObjectCreationHelper
    {
        /// <summary>
        /// Generates SQL to create a table based on an EntityStructure.
        /// </summary>
        /// <param name="entity">The EntityStructure containing entity definition</param>
        /// <returns>A tuple containing the SQL statement, success flag, and any error message</returns>
        public static (string Sql, bool Success, string ErrorMessage) GenerateCreateTableSQL(EntityStructure entity)
        {
            try
            {
                var sql = GenerateCreateTableSQLInternal(entity);
                return (sql, true, string.Empty);
            }
            catch (Exception ex)
            {
                return (string.Empty, false, ex.Message);
            }
        }

        /// <summary>
        /// Generates a SQL query to add a primary key to a table in a specific RDBMS.
        /// </summary>
        /// <param name="rdbms">The type of RDBMS.</param>
        /// <param name="tableName">The name of the table.</param>
        /// <param name="primaryKey">The name of the primary key column.</param>
        /// <param name="type">The data type of the primary key column.</param>
        /// <returns>A SQL query to add a primary key to the specified table in the specified RDBMS.</returns>
        /// <exception cref="ArgumentException">Thrown when the specified RDBMS is not supported.</exception>
        public static string GeneratePrimaryKeyQuery(DataSourceType rdbms, string tableName, string primaryKey, string type)
        {
            if (string.IsNullOrWhiteSpace(tableName))
                throw new ArgumentException("Table name cannot be null or empty", nameof(tableName));

            if (string.IsNullOrWhiteSpace(primaryKey))
                throw new ArgumentException("Primary key name cannot be null or empty", nameof(primaryKey));

            switch (rdbms)
            {
                case DataSourceType.SqlServer:
                    return $"ALTER TABLE {tableName} ADD {primaryKey} {type} PRIMARY KEY IDENTITY";
                case DataSourceType.Mysql:
                    return $"ALTER TABLE {tableName} ADD {primaryKey} {type} PRIMARY KEY AUTO_INCREMENT";
                case DataSourceType.Postgre:
                    return $"ALTER TABLE {tableName} ADD {primaryKey} {type} PRIMARY KEY GENERATED ALWAYS AS IDENTITY";
                case DataSourceType.Oracle:
                    return $"ALTER TABLE {tableName} ADD {primaryKey} {type} GENERATED ALWAYS AS IDENTITY";
                case DataSourceType.DB2:
                    return $"ALTER TABLE {tableName} ADD {primaryKey} {type} GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY";
                case DataSourceType.FireBird:
                    return $"ALTER TABLE {tableName} ADD {primaryKey} {type} PRIMARY KEY";
                case DataSourceType.SqlLite:
                    return $"ALTER TABLE {tableName} ADD {primaryKey} {type} PRIMARY KEY AUTOINCREMENT";
                case DataSourceType.Couchbase:
                case DataSourceType.Redis:
                case DataSourceType.MongoDB:
                    return "NoSQL databases typically do not have primary keys in the same way RDBMS do.";
                default:
                    return "RDBMS not supported.";
            }
        }

        /// <summary>
        /// Generates SQL to add a primary key to a table based on its entity structure.
        /// </summary>
        /// <param name="entity">The entity structure containing table and primary key information.</param>
        /// <returns>A tuple containing the SQL statement, success flag, and error message (if any).</returns>
        public static (string Sql, bool Success, string ErrorMessage) GeneratePrimaryKeyFromEntity(EntityStructure entity)
        {
            try
            {
                if (entity == null)
                    throw new ArgumentNullException(nameof(entity), "Entity structure must be provided.");

                if (string.IsNullOrWhiteSpace(entity.EntityName))
                    return (string.Empty, false, "Entity name cannot be empty.");

                // Determine the primary key field(s)
                var primaryKeyFields = entity.Fields.Where(f => f.IsKey).ToList();

                if (!primaryKeyFields.Any())
                    return (string.Empty, false, "No primary key defined for the entity.");

                // Generate the primary key query for each field (assuming composite keys are not used for simplicity)
                var queries = new List<string>();
                foreach (var primaryKeyField in primaryKeyFields)
                {
                    string query = GeneratePrimaryKeyQuery(entity.DatabaseType, entity.EntityName, primaryKeyField.fieldname, MapDataType(primaryKeyField.fieldtype, entity.DatabaseType));
                    queries.Add(query);
                }

                // Combine queries with "; " for execution
                string combinedQuery = string.Join("; ", queries);

                return (combinedQuery, true, string.Empty);
            }
            catch (Exception ex)
            {
                return (string.Empty, false, ex.Message);
            }
        }

        /// <summary>
        /// Generates a query to create an index
        /// </summary>
        /// <param name="databaseType">Database type</param>
        /// <param name="tableName">Name of the table</param>
        /// <param name="indexName">Name of the index</param>
        /// <param name="columns">Array of column names</param>
        /// <param name="options">Optional index creation options</param>
        /// <returns>SQL statement to create the index</returns>
        public static string GenerateCreateIndexQuery(DataSourceType databaseType, string tableName, string indexName, 
            string[] columns, Dictionary<string, object> options = null)
        {
            if (string.IsNullOrWhiteSpace(tableName))
                throw new ArgumentException("Table name cannot be null or empty", nameof(tableName));
            
            if (string.IsNullOrWhiteSpace(indexName))
                throw new ArgumentException("Index name cannot be null or empty", nameof(indexName));
            
            if (columns == null || columns.Length == 0)
                throw new ArgumentException("Columns cannot be null or empty", nameof(columns));

            var columnList = string.Join(", ", columns);
            var isUnique = options?.ContainsKey("unique") == true && (bool)options["unique"];
            var uniqueKeyword = isUnique ? "UNIQUE " : "";

            return databaseType switch
            {
                DataSourceType.SqlServer => $"CREATE {uniqueKeyword}INDEX {indexName} ON {tableName} ({columnList})",
                DataSourceType.Mysql => $"CREATE {uniqueKeyword}INDEX {indexName} ON {tableName} ({columnList})",
                DataSourceType.Postgre => $"CREATE {uniqueKeyword}INDEX {indexName} ON {tableName} ({columnList})",
                DataSourceType.Oracle => $"CREATE {uniqueKeyword}INDEX {indexName} ON {tableName} ({columnList})",
                DataSourceType.SqlLite => $"CREATE {uniqueKeyword}INDEX {indexName} ON {tableName} ({columnList})",
                DataSourceType.DB2 => $"CREATE {uniqueKeyword}INDEX {indexName} ON {tableName} ({columnList})",
                DataSourceType.FireBird => $"CREATE {uniqueKeyword}INDEX {indexName} ON {tableName} ({columnList})",
                DataSourceType.SnowFlake => $"CREATE {uniqueKeyword}INDEX {indexName} ON {tableName} ({columnList})",
                DataSourceType.Cockroach => $"CREATE {uniqueKeyword}INDEX {indexName} ON {tableName} ({columnList})",
                DataSourceType.Vertica => $"CREATE {uniqueKeyword}INDEX {indexName} ON {tableName} ({columnList})",
                _ => $"CREATE {uniqueKeyword}INDEX {indexName} ON {tableName} ({columnList})"
            };
        }

        /// <summary>
        /// Generates SQL to create a unique index on a table based on its entity structure.
        /// </summary>
        /// <param name="entity">The entity structure containing table and index information.</param>
        /// <returns>A tuple containing the SQL statement, success flag, and error message (if any).</returns>
        public static (string Sql, bool Success, string ErrorMessage) GenerateUniqueIndexFromEntity(EntityStructure entity)
        {
            try
            {
                if (entity == null)
                    throw new ArgumentNullException(nameof(entity), "Entity structure must be provided.");

                if (string.IsNullOrWhiteSpace(entity.EntityName))
                    return (string.Empty, false, "Entity name cannot be empty.");

                // Determine the unique fields (assuming unique index is based on one field for simplicity)
                var uniqueFields = entity.Fields.Where(f => f.IsUnique).ToList();

                if (!uniqueFields.Any())
                    return (string.Empty, false, "No unique fields defined for the entity.");

                // Generate the unique index query for each field
                var queries = new List<string>();
                foreach (var uniqueField in uniqueFields)
                {
                    string query = GenerateCreateIndexQuery(entity.DatabaseType, entity.EntityName, $"{entity.EntityName}_{uniqueField.fieldname}_ux", new[] { uniqueField.fieldname }, new Dictionary<string, object> { { "unique", true } });
                    queries.Add(query);
                }

                // Combine queries with "; " for execution
                string combinedQuery = string.Join("; ", queries);

                return (combinedQuery, true, string.Empty);
            }
            catch (Exception ex)
            {
                return (string.Empty, false, ex.Message);
            }
        }

        /// <summary>
        /// Generates SQL to drop an entity
        /// </summary>
        /// <param name="dataSourceType">Database type</param>
        /// <param name="entityName">Name of the entity to drop</param>
        /// <returns>SQL statement to drop the entity</returns>
        public static string GetDropEntity(DataSourceType dataSourceType, string entityName)
        {
            if (string.IsNullOrWhiteSpace(entityName))
                throw new ArgumentException("Entity name cannot be null or empty", nameof(entityName));

            return dataSourceType switch
            {
                DataSourceType.SqlServer => $"DROP TABLE IF EXISTS {entityName}",
                DataSourceType.Mysql => $"DROP TABLE IF EXISTS {entityName}",
                DataSourceType.Postgre => $"DROP TABLE IF EXISTS {entityName}",
                DataSourceType.Oracle => $"DROP TABLE {entityName}",
                DataSourceType.SqlLite => $"DROP TABLE IF EXISTS {entityName}",
                DataSourceType.DB2 => $"DROP TABLE {entityName}",
                DataSourceType.FireBird => $"DROP TABLE {entityName}",
                DataSourceType.SnowFlake => $"DROP TABLE IF EXISTS {entityName}",
                DataSourceType.Cockroach => $"DROP TABLE IF EXISTS {entityName}",
                DataSourceType.Vertica => $"DROP TABLE IF EXISTS {entityName}",
                DataSourceType.GoogleBigQuery => $"DROP TABLE IF EXISTS {entityName}",
                DataSourceType.AWSRedshift => $"DROP TABLE IF EXISTS {entityName}",
                DataSourceType.ClickHouse => $"DROP TABLE IF EXISTS {entityName}",
                _ => $"DROP TABLE {entityName}"
            };
        }

        /// <summary>
        /// Generates SQL to truncate a table
        /// </summary>
        /// <param name="dataSourceType">Database type</param>
        /// <param name="tableName">Name of the table to truncate</param>
        /// <param name="schemaName">Schema name (optional)</param>
        /// <returns>SQL statement to truncate the table</returns>
        public static string GetTruncateTableQuery(DataSourceType dataSourceType, string tableName, string schemaName = null)
        {
            if (string.IsNullOrWhiteSpace(tableName))
                throw new ArgumentException("Table name cannot be null or empty", nameof(tableName));

            var fullTableName = string.IsNullOrEmpty(schemaName) ? tableName : $"{schemaName}.{tableName}";
            
            return dataSourceType switch
            {
                DataSourceType.SqlServer => $"TRUNCATE TABLE {fullTableName}",
                DataSourceType.Mysql => $"TRUNCATE TABLE {fullTableName}",
                DataSourceType.Postgre => $"TRUNCATE TABLE {fullTableName}",
                DataSourceType.Oracle => $"TRUNCATE TABLE {fullTableName}",
                DataSourceType.DB2 => $"TRUNCATE TABLE {fullTableName} IMMEDIATE",
                DataSourceType.FireBird => $"DELETE FROM {fullTableName}", // Firebird doesn't support TRUNCATE
                DataSourceType.SqlLite => $"DELETE FROM {fullTableName}", // SQLite doesn't support TRUNCATE
                _ => $"DELETE FROM {fullTableName}"
            };
        }

        /// <summary>
        /// Internal method to generate CREATE TABLE SQL from EntityStructure.
        /// </summary>
        /// <param name="entity">The entity structure</param>
        /// <returns>CREATE TABLE SQL statement</returns>
        private static string GenerateCreateTableSQLInternal(EntityStructure entity)
        {
            if (entity?.Fields == null || !entity.Fields.Any())
                throw new ArgumentException("Entity has no fields defined");

            var tableName = entity.EntityName;
            var columns = new List<string>();

            foreach (var field in entity.Fields)
            {
                var columnDef = GenerateColumnDefinition(field, entity.DatabaseType);
                columns.Add(columnDef);
            }

            var sql = $"CREATE TABLE {tableName} ({string.Join(", ", columns)})";
            return sql;
        }

        /// <summary>
        /// Generates a column definition for CREATE TABLE statements.
        /// </summary>
        /// <param name="field">The entity field</param>
        /// <param name="databaseType">The target database type</param>
        /// <returns>Column definition string</returns>
        private static string GenerateColumnDefinition(EntityField field, DataSourceType databaseType)
        {
            var dataType = MapDataType(field.fieldtype, databaseType);
            var nullable = field.AllowDBNull ? "" : " NOT NULL";
            var identity = field.IsAutoIncrement ? GetIdentityClause(databaseType) : "";
            
            return $"{field.fieldname} {dataType}{nullable}{identity}";
        }

        /// <summary>
        /// Maps .NET data types to database-specific data types.
        /// </summary>
        /// <param name="fieldType">The .NET field type</param>
        /// <param name="databaseType">The target database type</param>
        /// <returns>Database-specific data type</returns>
        private static string MapDataType(string fieldType, DataSourceType databaseType)
        {
            if (string.IsNullOrEmpty(fieldType))
                return "VARCHAR(255)"; // Default fallback

            // Normalize the field type
            string normalizedType = fieldType.ToUpper().Trim();
            
            // Remove System. prefix if present for mapping purposes
            string baseType = normalizedType.StartsWith("SYSTEM.") ? normalizedType.Substring(7) : normalizedType;

            // Try to get mappings from DataTypeFieldMappingHelper first
            var mappings = DataTypeFieldMappingHelper.GetDataTypes(databaseType, null);
            if (mappings != null && mappings.Any())
            {
                // Look for exact .NET type match
                var exactMatch = mappings.FirstOrDefault(m => 
                    m.NetDataType.Equals(fieldType, StringComparison.OrdinalIgnoreCase) && m.Fav);
                
                if (exactMatch == null)
                {
                    exactMatch = mappings.FirstOrDefault(m => 
                        m.NetDataType.Equals(fieldType, StringComparison.OrdinalIgnoreCase));
                }

                if (exactMatch != null)
                {
                    return exactMatch.DataType;
                }

                // Try to match common type patterns
                var patternMatch = mappings.FirstOrDefault(m => 
                    m.NetDataType.EndsWith("." + baseType, StringComparison.OrdinalIgnoreCase) && m.Fav);
                
                if (patternMatch == null)
                {
                    patternMatch = mappings.FirstOrDefault(m => 
                        m.NetDataType.EndsWith("." + baseType, StringComparison.OrdinalIgnoreCase));
                }

                if (patternMatch != null)
                {
                    return patternMatch.DataType;
                }
            }

            // Fallback to original mapping logic if DataTypeFieldMappingHelper doesn't have the mapping
            return databaseType switch
            {
                DataSourceType.SqlServer => baseType switch
                {
                    "STRING" or "TEXT" => "NVARCHAR(MAX)",
                    "INT" or "INTEGER" or "INT32" => "INT",
                    "LONG" or "INT64" => "BIGINT",
                    "SHORT" or "INT16" => "SMALLINT",
                    "BYTE" => "TINYINT",
                    "DECIMAL" or "DOUBLE" => "DECIMAL(18,2)",
                    "SINGLE" or "FLOAT" => "REAL",
                    "DATETIME" => "DATETIME2",
                    "DATETIMEOFFSET" => "DATETIMEOFFSET",
                    "TIMESPAN" => "TIME",
                    "BOOL" or "BOOLEAN" => "BIT",
                    "GUID" => "UNIQUEIDENTIFIER",
                    "BYTE[]" => "VARBINARY(MAX)",
                    "CHAR" => "NCHAR(1)",
                    _ => "NVARCHAR(255)"
                },
                DataSourceType.Mysql => baseType switch
                {
                    "STRING" or "TEXT" => "TEXT",
                    "INT" or "INTEGER" or "INT32" => "INT",
                    "LONG" or "INT64" => "BIGINT",
                    "SHORT" or "INT16" => "SMALLINT",
                    "BYTE" => "TINYINT UNSIGNED",
                    "DECIMAL" or "DOUBLE" => "DECIMAL(18,2)",
                    "SINGLE" or "FLOAT" => "FLOAT",
                    "DATETIME" => "DATETIME",
                    "TIMESPAN" => "TIME",
                    "BOOL" or "BOOLEAN" => "BOOLEAN",
                    "GUID" => "CHAR(36)",
                    "BYTE[]" => "LONGBLOB",
                    "CHAR" => "CHAR(1)",
                    _ => "VARCHAR(255)"
                },
                DataSourceType.Postgre => baseType switch
                {
                    "STRING" or "TEXT" => "TEXT",
                    "INT" or "INTEGER" or "INT32" => "INTEGER",
                    "LONG" or "INT64" => "BIGINT",
                    "SHORT" or "INT16" => "SMALLINT",
                    "BYTE" => "SMALLINT",
                    "DECIMAL" => "NUMERIC(18,2)",
                    "DOUBLE" => "DOUBLE PRECISION",
                    "SINGLE" or "FLOAT" => "REAL",
                    "DATETIME" => "TIMESTAMP",
                    "DATETIMEOFFSET" => "TIMESTAMPTZ",
                    "TIMESPAN" => "INTERVAL",
                    "BOOL" or "BOOLEAN" => "BOOLEAN",
                    "GUID" => "UUID",
                    "BYTE[]" => "BYTEA",
                    "CHAR" => "CHAR(1)",
                    _ => "VARCHAR(255)"
                },
                DataSourceType.Oracle => baseType switch
                {
                    "STRING" or "TEXT" => "NVARCHAR2(4000)",
                    "INT" or "INTEGER" or "INT32" => "NUMBER(10)",
                    "LONG" or "INT64" => "NUMBER(19)",
                    "SHORT" or "INT16" => "NUMBER(5)",
                    "BYTE" => "NUMBER(3)",
                    "DECIMAL" => "NUMBER(18,2)",
                    "DOUBLE" or "SINGLE" or "FLOAT" => "BINARY_DOUBLE",
                    "DATETIME" => "TIMESTAMP",
                    "BOOL" or "BOOLEAN" => "NUMBER(1)",
                    "GUID" => "RAW(16)",
                    "BYTE[]" => "BLOB",
                    "CHAR" => "NCHAR(1)",
                    _ => "NVARCHAR2(255)"
                },
                DataSourceType.SqlLite => baseType switch
                {
                    "STRING" or "TEXT" => "TEXT",
                    "INT" or "INTEGER" or "INT32" or "LONG" or "INT64" or "SHORT" or "INT16" or "BYTE" => "INTEGER",
                    "DECIMAL" or "DOUBLE" or "SINGLE" or "FLOAT" => "REAL",
                    "DATETIME" => "TEXT", // SQLite stores dates as text
                    "BOOL" or "BOOLEAN" => "INTEGER",
                    "GUID" => "TEXT",
                    "BYTE[]" => "BLOB",
                    "CHAR" => "TEXT",
                    _ => "TEXT"
                },
                DataSourceType.DB2 => baseType switch
                {
                    "STRING" or "TEXT" => "VARCHAR(255)",
                    "INT" or "INTEGER" or "INT32" => "INTEGER",
                    "LONG" or "INT64" => "BIGINT",
                    "SHORT" or "INT16" => "SMALLINT",
                    "BYTE" => "SMALLINT",
                    "DECIMAL" => "DECIMAL(18,2)",
                    "DOUBLE" => "DOUBLE",
                    "SINGLE" or "FLOAT" => "REAL",
                    "DATETIME" => "TIMESTAMP",
                    "BOOL" or "BOOLEAN" => "SMALLINT",
                    "GUID" => "CHAR(36)",
                    "BYTE[]" => "BLOB",
                    "CHAR" => "CHAR(1)",
                    _ => "VARCHAR(255)"
                },
                DataSourceType.FireBird => baseType switch
                {
                    "STRING" or "TEXT" => "VARCHAR(255)",
                    "INT" or "INTEGER" or "INT32" => "INTEGER",
                    "LONG" or "INT64" => "BIGINT",
                    "SHORT" or "INT16" => "SMALLINT",
                    "BYTE" => "SMALLINT",
                    "DECIMAL" => "DECIMAL(18,2)",
                    "DOUBLE" => "DOUBLE PRECISION",
                    "SINGLE" or "FLOAT" => "FLOAT",
                    "DATETIME" => "TIMESTAMP",
                    "BOOL" or "BOOLEAN" => "SMALLINT",
                    "GUID" => "CHAR(36)",
                    "BYTE[]" => "BLOB",
                    "CHAR" => "CHAR(1)",
                    _ => "VARCHAR(255)"
                },
                DataSourceType.SnowFlake => baseType switch
                {
                    "STRING" or "TEXT" => "VARCHAR",
                    "INT" or "INTEGER" or "INT32" => "INTEGER",
                    "LONG" or "INT64" => "INTEGER",
                    "SHORT" or "INT16" => "INTEGER",
                    "BYTE" => "INTEGER",
                    "DECIMAL" => "DECIMAL(18,2)",
                    "DOUBLE" or "SINGLE" or "FLOAT" => "FLOAT",
                    "DATETIME" => "TIMESTAMP_NTZ",
                    "DATETIMEOFFSET" => "TIMESTAMP_TZ",
                    "TIMESPAN" => "TIME",
                    "BOOL" or "BOOLEAN" => "BOOLEAN",
                    "GUID" => "VARCHAR(36)",
                    "BYTE[]" => "BINARY",
                    "CHAR" => "CHAR(1)",
                    _ => "VARCHAR"
                },
                DataSourceType.Cockroach => baseType switch
                {
                    "STRING" or "TEXT" => "STRING",
                    "INT" or "INTEGER" or "INT32" => "INT4",
                    "LONG" or "INT64" => "INT8",
                    "SHORT" or "INT16" => "INT2",
                    "BYTE" => "INT2",
                    "DECIMAL" => "DECIMAL(18,2)",
                    "DOUBLE" or "SINGLE" or "FLOAT" => "FLOAT8",
                    "DATETIME" => "TIMESTAMP",
                    "TIMESPAN" => "INTERVAL",
                    "BOOL" or "BOOLEAN" => "BOOL",
                    "GUID" => "UUID",
                    "BYTE[]" => "BYTES",
                    "CHAR" => "CHAR(1)",
                    _ => "STRING"
                },
                DataSourceType.MongoDB => baseType switch
                {
                    "STRING" or "TEXT" => "String",
                    "INT" or "INTEGER" or "INT32" => "Int32",
                    "LONG" or "INT64" => "Int64",
                    "DECIMAL" or "DOUBLE" => "Double",
                    "DATETIME" => "DateTime",
                    "BOOL" or "BOOLEAN" => "Boolean",
                    "GUID" => "String",
                    "BYTE[]" => "Binary",
                    _ => "String"
                },
                // Add more database types as needed
                _ => baseType switch
                {
                    "STRING" or "TEXT" => "VARCHAR(255)",
                    "INT" or "INTEGER" or "INT32" => "INTEGER",
                    "LONG" or "INT64" => "BIGINT",
                    "DECIMAL" or "DOUBLE" => "DECIMAL(18,2)",
                    "DATETIME" => "TIMESTAMP",
                    "BOOL" or "BOOLEAN" => "BOOLEAN",
                    "BYTE[]" => "BLOB",
                    _ => "VARCHAR(255)"
                }
            };
        }

        /// <summary>
        /// Gets the identity clause SQL syntax for a specific database type
        /// </summary>
        /// <param name="databaseType">The database type</param>
        /// <returns>The identity clause syntax</returns>
        private static string GetIdentityClause(DataSourceType databaseType)
        {
            return databaseType switch
            {
                DataSourceType.SqlServer => " IDENTITY(1,1)",
                DataSourceType.Mysql => " AUTO_INCREMENT",
                DataSourceType.Postgre => " GENERATED ALWAYS AS IDENTITY",
                DataSourceType.Oracle => " GENERATED ALWAYS AS IDENTITY",
                DataSourceType.DB2 => " GENERATED BY DEFAULT AS IDENTITY",
                DataSourceType.SqlLite => " AUTOINCREMENT",
                _ => string.Empty
            };
        }
    }
}