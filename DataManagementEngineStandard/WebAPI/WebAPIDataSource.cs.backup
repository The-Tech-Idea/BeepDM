
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using TheTechIdea.Beep.Logger;
using TheTechIdea.Beep.Utilities;
using System.Data;
using TheTechIdea.Beep.DataBase;
using System.Net.Http;
using TheTechIdea.Beep.Report;
using TheTechIdea.Beep.Editor;
using TheTechIdea.Beep.ConfigUtil;
using TheTechIdea.Beep.Addin;
using System.ComponentModel;
using System.Net;
using System.Text.Json;
using System.Threading;
using System.Collections.Concurrent;
using System.Security.Authentication;
using System.Net.Http.Headers;
using System.IO;
using System.Reflection;



namespace TheTechIdea.Beep.WebAPI
{
    /// <summary>
    /// Optimized Web API Data Source implementation for connecting to REST APIs, SaaS, and commercial services
    /// Supports OAuth, JWT, API Keys, retry policies, caching, and comprehensive error handling
    /// </summary>
    public class WebAPIDataSource : IDataSource
    {
        #region Events and Properties
        
        /// <summary>Event raised when operations pass messages</summary>
        public event EventHandler<PassedArgs> PassEvent;
        
        /// <summary>Type of data source</summary>
        public DataSourceType DatasourceType { get; set; }
        
        /// <summary>Category of data source</summary>
        public DatasourceCategory Category { get; set; }
        
        /// <summary>Data connection instance</summary>
        public IDataConnection Dataconnection { get; set; }
        
        /// <summary>Name of the data source</summary>
        public string DatasourceName { get; set; }
        
        /// <summary>Error handling object</summary>
        public IErrorsInfo ErrorObject { get; set; }
        
        /// <summary>Unique identifier</summary>
        public string Id { get; set; }
        
        /// <summary>Logger instance</summary>
        public IDMLogger Logger { get; set; }
        
        /// <summary>List of entity names</summary>
        public List<string> EntitiesNames { get; set; }
        
        /// <summary>List of entity structures</summary>
        public List<EntityStructure> Entities { get; set; } = new List<EntityStructure>();
        
        /// <summary>Data management editor instance</summary>
        public IDMEEditor DMEEditor { get; set; }
        
        /// <summary>Records collection</summary>
        public List<object> Records { get; set; }
        
        /// <summary>Connection status</summary>
        public ConnectionState ConnectionStatus { get; set; }
        
        /// <summary>Column delimiter for queries</summary>
        public virtual string ColumnDelimiter { get; set; } = "''";
        
        /// <summary>Parameter delimiter</summary>
        public virtual string ParameterDelimiter { get; set; } = ":";
        
        /// <summary>HTTP client for API calls</summary>
        public HttpClient client { get; set; }
        
        /// <summary>Unique GUID identifier</summary>
        public string GuidID { get; set; } = Guid.NewGuid().ToString();

        #endregion

        #region Private Fields

        private readonly WebAPIDataConnection cn;
        private readonly ConcurrentDictionary<string, object> _cache = new ConcurrentDictionary<string, object>();
        private readonly ConcurrentDictionary<string, DateTime> _cacheTimestamps = new ConcurrentDictionary<string, DateTime>();
        private readonly SemaphoreSlim _rateLimitSemaphore = new SemaphoreSlim(10, 10); // Allow 10 concurrent requests
        private readonly Timer _cacheCleanupTimer;
        private string _accessToken;
        private DateTime _tokenExpiry = DateTime.MinValue;
        private readonly object _tokenLock = new object();

        // Configuration settings
        private int _retryCount = 3;
        private int _retryDelayMs = 1000;
        private int _timeoutMs = 30000;
        private int _cacheExpiryMinutes = 15;
        private int _maxConcurrentRequests = 10;

        #endregion

        #region Constructor

        /// <summary>
        /// Initializes a new instance of WebAPIDataSource with comprehensive API support
        /// </summary>
        public WebAPIDataSource(string datasourcename, IDMLogger logger, IDMEEditor pDMEEditor, DataSourceType databasetype, IErrorsInfo per)
        {
            DatasourceName = datasourcename;
            Logger = logger;
            ErrorObject = per;
            DMEEditor = pDMEEditor;
            DatasourceType = databasetype;
            Category = DatasourceCategory.WEBAPI;
            
            // Initialize connection
            Dataconnection = new WebAPIDataConnection
            {
                Logger = logger,
                ErrorObject = ErrorObject,
                DMEEditor = pDMEEditor
            };
            
            // Configure HttpClient with optimizations
            var handler = new HttpClientHandler()
            {
                AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate
            };
            
            client = new HttpClient(handler)
            {
                Timeout = TimeSpan.FromMilliseconds(_timeoutMs)
            };
            
            // Set default headers
            client.DefaultRequestHeaders.Add("User-Agent", "BeepDM-WebAPI/1.0");
            client.DefaultRequestHeaders.Add("Accept", "application/json, application/xml, text/plain, */*");
            client.DefaultRequestHeaders.Add("Accept-Encoding", "gzip, deflate");
            
            // Get connection properties
            Dataconnection.ConnectionProp = DMEEditor.ConfigEditor.DataConnections
                .Where(c => c.ConnectionName == datasourcename).FirstOrDefault();
            
            cn = (WebAPIDataConnection)Dataconnection;
            
            // Load configuration
            LoadConfiguration();
            
            // Setup cache cleanup timer (runs every 5 minutes)
            _cacheCleanupTimer = new Timer(CleanupCache, null, TimeSpan.FromMinutes(5), TimeSpan.FromMinutes(5));
            
            // Open connection
            cn.OpenConnection();
            ConnectionStatus = cn.ConnectionStatus;
        }

        #endregion

        #region Configuration

        private void LoadConfiguration()
        {
            // Configuration is typically stored in connection properties
            // For now, we'll use default values and can be extended later
            // based on the actual structure of ConnectionProp.Parameters
        }

        private void CleanupCache(object state)
        {
            try
            {
                var expiredKeys = new List<string>();
                var cutoffTime = DateTime.Now.AddMinutes(-_cacheExpiryMinutes);
                
                foreach (var kvp in _cacheTimestamps)
                {
                    if (kvp.Value < cutoffTime)
                    {
                        expiredKeys.Add(kvp.Key);
                    }
                }
                
                foreach (var key in expiredKeys)
                {
                    _cache.TryRemove(key, out _);
                    _cacheTimestamps.TryRemove(key, out _);
                }
                
                if (expiredKeys.Count > 0)
                {
                    DMEEditor.AddLogMessage("Success", $"Cleaned up {expiredKeys.Count} expired cache entries", 
                        DateTime.Now, 0, DatasourceName, Errors.Ok);
                }
            }
            catch (Exception ex)
            {
                DMEEditor.AddLogMessage("Warning", $"Error during cache cleanup: {ex.Message}", 
                    DateTime.Now, 0, DatasourceName, Errors.Warning);
            }
        }

        #endregion

        #region Authentication Support

        /// <summary>
        /// Refreshes the access token for OAuth/JWT authentication
        /// </summary>
        private async Task<bool> RefreshTokenAsync()
        {
            try
            {
                // Use ConnectionString field to store auth URL if needed
                var authUrl = GetConnectionParameter("AuthUrl");
                if (string.IsNullOrEmpty(authUrl))
                    return true; // No authentication required
                
                var authRequest = new HttpRequestMessage(HttpMethod.Post, authUrl);
                
                // Prepare authentication payload based on auth type
                var authPayload = PrepareAuthPayload();
                if (!string.IsNullOrEmpty(authPayload))
                {
                    authRequest.Content = new StringContent(authPayload, Encoding.UTF8, "application/json");
                }
                
                var response = await client.SendAsync(authRequest);
                response.EnsureSuccessStatusCode();
                
                var responseContent = await response.Content.ReadAsStringAsync();
                var tokenResponse = JsonSerializer.Deserialize<Dictionary<string, object>>(responseContent);
                
                if (tokenResponse.ContainsKey("access_token"))
                {
                    _accessToken = tokenResponse["access_token"].ToString();
                    
                    // Set expiry time (default 1 hour if not specified)
                    var expiresIn = tokenResponse.ContainsKey("expires_in") 
                        ? Convert.ToInt32(tokenResponse["expires_in"]) 
                        : 3600;
                    _tokenExpiry = DateTime.Now.AddSeconds(expiresIn - 60); // Refresh 1 minute early
                    
                    return true;
                }
            }
            catch (Exception ex)
            {
                DMEEditor.AddLogMessage("Error", $"Token refresh failed: {ex.Message}", 
                    DateTime.Now, 0, DatasourceName, Errors.Failed);
            }
            
            return false;
        }

        private string GetConnectionParameter(string paramName)
        {
            // Helper method to get parameters from connection properties
            // This can be extended based on how parameters are actually stored
            return Dataconnection.ConnectionProp.ConnectionString; // Placeholder
        }

        private string PrepareAuthPayload()
        {
            var authType = GetConnectionParameter("AuthType")?.ToLower();
            
            switch (authType)
            {
                case "oauth2_client_credentials":
                    return JsonSerializer.Serialize(new
                    {
                        grant_type = "client_credentials",
                        client_id = GetConnectionParameter("ClientId"),
                        client_secret = GetConnectionParameter("ClientSecret"),
                        scope = GetConnectionParameter("Scope") ?? ""
                    });
                    
                case "oauth2_password":
                    return JsonSerializer.Serialize(new
                    {
                        grant_type = "password",
                        username = Dataconnection.ConnectionProp.UserID,
                        password = Dataconnection.ConnectionProp.Password,
                        client_id = GetConnectionParameter("ClientId"),
                        client_secret = GetConnectionParameter("ClientSecret")
                    });
                    
                default:
                    return string.Empty;
            }
        }

        private async Task<bool> EnsureAuthenticatedAsync()
        {
            var authUrl = GetConnectionParameter("AuthUrl");
            if (string.IsNullOrEmpty(authUrl))
                return true; // No authentication required
            
            lock (_tokenLock)
            {
                if (DateTime.Now < _tokenExpiry && !string.IsNullOrEmpty(_accessToken))
                    return true; // Token still valid
            }
            
            return await RefreshTokenAsync();
        }

        #endregion

        #region HTTP Request Methods

        private async Task<HttpRequestMessage> PrepareRequestAsync(string endpoint, HttpMethod method, object data = null)
        {
            await EnsureAuthenticatedAsync();
            
            var request = new HttpRequestMessage(method, BuildEndpointUrl(endpoint));
            
            // Add authentication
            AddAuthenticationHeaders(request);
            
            // Add custom headers
            AddCustomHeaders(request);
            
            // Add request body for POST/PUT/PATCH
            if (data != null && (method == HttpMethod.Post || method == HttpMethod.Put || method == HttpMethod.Patch))
            {
                var json = JsonSerializer.Serialize(data);
                request.Content = new StringContent(json, Encoding.UTF8, "application/json");
            }
            
            return request;
        }

        private string BuildEndpointUrl(string endpoint)
        {
            var baseUrl = Dataconnection.ConnectionProp.Url?.TrimEnd('/');
            endpoint = endpoint?.TrimStart('/');
            
            var url = $"{baseUrl}/{endpoint}";
            
            // Replace API key placeholder if present
            if (!string.IsNullOrEmpty(Dataconnection.ConnectionProp.ApiKey))
            {
                url = url.Replace("@apikey", Dataconnection.ConnectionProp.ApiKey);
            }
            
            return url;
        }

        private void AddAuthenticationHeaders(HttpRequestMessage request)
        {
            var authType = GetConnectionParameter("AuthType")?.ToLower();
            
            switch (authType)
            {
                case "bearer":
                case "oauth2_client_credentials":
                case "oauth2_password":
                    if (!string.IsNullOrEmpty(_accessToken))
                        request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", _accessToken);
                    break;
                    
                case "apikey":
                    if (!string.IsNullOrEmpty(Dataconnection.ConnectionProp.ApiKey))
                    {
                        var apiKeyHeader = GetConnectionParameter("ApiKeyHeader") ?? "X-API-Key";
                        request.Headers.Add(apiKeyHeader, Dataconnection.ConnectionProp.ApiKey);
                    }
                    break;
                    
                case "basic":
                    if (!string.IsNullOrEmpty(Dataconnection.ConnectionProp.UserID))
                    {
                        var credentials = Convert.ToBase64String(
                            Encoding.UTF8.GetBytes($"{Dataconnection.ConnectionProp.UserID}:{Dataconnection.ConnectionProp.Password}"));
                        request.Headers.Authorization = new AuthenticationHeaderValue("Basic", credentials);
                    }
                    break;
            }
        }

        private void AddCustomHeaders(HttpRequestMessage request)
        {
            if (Dataconnection.ConnectionProp.Headers != null)
            {
                foreach (var header in Dataconnection.ConnectionProp.Headers)
                {
                    try
                    {
                        request.Headers.Add(header.Headername, header.Headervalue);
                    }
                    catch (Exception ex)
                    {
                        // Some headers might need to be added to content headers
                        try
                        {
                            request.Content?.Headers.Add(header.Headername, header.Headervalue);
                        }
                        catch
                        {
                            DMEEditor.AddLogMessage("Warning", $"Could not add header {header.Headername}: {ex.Message}",
                                DateTime.Now, 0, DatasourceName, Errors.Warning);
                        }
                    }
                }
            }
        }

        private async Task<T> ExecuteWithRetryAsync<T>(Func<Task<T>> operation, string operationName)
        {
            var lastException = new Exception();
            
            for (int attempt = 0; attempt <= _retryCount; attempt++)
            {
                try
                {
                    await _rateLimitSemaphore.WaitAsync();
                    
                    try
                    {
                        return await operation();
                    }
                    finally
                    {
                        _rateLimitSemaphore.Release();
                    }
                }
                catch (Exception ex)
                {
                    lastException = ex;
                    
                    if (attempt < _retryCount && ShouldRetry(ex))
                    {
                        var delay = CalculateDelay(attempt);
                        DMEEditor.AddLogMessage("Warning", 
                            $"Attempt {attempt + 1} failed for {operationName}, retrying in {delay}ms: {ex.Message}",
                            DateTime.Now, 0, DatasourceName, Errors.Warning);
                        
                        await Task.Delay(delay);
                        continue;
                    }
                    
                    DMEEditor.AddLogMessage("Error", $"Operation {operationName} failed after {attempt + 1} attempts: {ex.Message}",
                        DateTime.Now, 0, DatasourceName, Errors.Failed);
                    throw;
                }
            }
            
            throw lastException;
        }

        private bool ShouldRetry(Exception ex)
        {
            // Retry on network errors, timeouts, and 5xx server errors
            return ex is HttpRequestException || 
                   ex is TaskCanceledException ||
                   (ex is WebException webEx && (
                       webEx.Status == WebExceptionStatus.Timeout ||
                       webEx.Status == WebExceptionStatus.ConnectionClosed ||
                       webEx.Status == WebExceptionStatus.ConnectFailure
                   ));
        }

        private int CalculateDelay(int attemptNumber)
        {
            // Exponential backoff with jitter
            var delay = _retryDelayMs * Math.Pow(2, attemptNumber);
            var jitter = new Random().Next(0, (int)(delay * 0.1)); // Add up to 10% jitter
            return (int)(delay + jitter);
        }

        #endregion

        #region Caching Support

        private string GenerateCacheKey(string operation, params string[] parameters)
        {
            var key = $"{DatasourceName}:{operation}";
            if (parameters?.Length > 0)
            {
                key += ":" + string.Join(":", parameters);
            }
            return key;
        }

        private T GetFromCache<T>(string cacheKey) where T : class
        {
            if (_cache.TryGetValue(cacheKey, out var cached) && 
                _cacheTimestamps.TryGetValue(cacheKey, out var timestamp))
            {
                if (DateTime.Now - timestamp < TimeSpan.FromMinutes(_cacheExpiryMinutes))
                {
                    return cached as T;
                }
                
                // Expired cache entry
                _cache.TryRemove(cacheKey, out _);
                _cacheTimestamps.TryRemove(cacheKey, out _);
            }
            
            return null;
        }

        private void SetCache<T>(string cacheKey, T value)
        {
            _cache.TryAdd(cacheKey, value);
            _cacheTimestamps.TryAdd(cacheKey, DateTime.Now);
        }

        #endregion
        #region IDataSource Implementation

        /// <summary>Gets scalar value from API endpoint</summary>
        public virtual Task<double> GetScalarAsync(string query)
        {
            return Task.Run(() => GetScalar(query));
        }

        /// <summary>Gets scalar value from API endpoint</summary>
        public virtual double GetScalar(string query)
        {
            ErrorObject.Flag = Errors.Ok;
            try
            {
                var result = ExecuteWithRetryAsync(async () =>
                {
                    var request = await PrepareRequestAsync(query, HttpMethod.Get);
                    var response = await client.SendAsync(request);
                    response.EnsureSuccessStatusCode();
                    
                    var content = await response.Content.ReadAsStringAsync();
                    if (double.TryParse(content, out double value))
                        return value;
                    
                    // Try to extract number from JSON
                    if (content.StartsWith("{") || content.StartsWith("["))
                    {
                        var json = JsonSerializer.Deserialize<JsonElement>(content);
                        if (json.ValueKind == JsonValueKind.Number)
                            return json.GetDouble();
                    }
                    
                    return 0.0;
                }, "GetScalar").Result;
                
                return result;
            }
            catch (Exception ex)
            {
                DMEEditor.AddLogMessage("Fail", $"Error in executing scalar query ({ex.Message})", DateTime.Now, 0, "", Errors.Failed);
                return 0.0;
            }
        }

        /// <summary>Opens connection to the web API</summary>
        public ConnectionState Openconnection()
        {
            try
            {
                cn.OpenConnection();
                ConnectionStatus = cn.ConnectionStatus;
                return ConnectionStatus;
            }
            catch (Exception ex)
            {
                DMEEditor.AddLogMessage("Error", $"Failed to open connection: {ex.Message}", DateTime.Now, 0, DatasourceName, Errors.Failed);
                ConnectionStatus = ConnectionState.Broken;
                return ConnectionStatus;
            }
        }

        /// <summary>Closes connection to the web API</summary>
        public ConnectionState Closeconnection()
        {
            try
            {
                client?.Dispose();
                ConnectionStatus = ConnectionState.Closed;
                return ConnectionStatus;
            }
            catch (Exception ex)
            {
                DMEEditor.AddLogMessage("Error", $"Failed to close connection: {ex.Message}", DateTime.Now, 0, DatasourceName, Errors.Failed);
                return ConnectionStatus;
            }
        }

        /// <summary>Gets the index of an entity by name</summary>
        public int GetEntityIdx(string entityName)
        {
            if (Entities.Count > 0)
            {
                return Entities.FindIndex(p => p.EntityName.Equals(entityName, StringComparison.InvariantCultureIgnoreCase) || 
                                             p.DatasourceEntityName.Equals(entityName, StringComparison.InvariantCultureIgnoreCase));
            }
            return -1;
        }

        /// <summary>Checks if entity exists in the data source</summary>
        public bool CheckEntityExist(string EntityName)
        {
            return Dataconnection.ConnectionProp.Entities.Any(o => o.EntityName.Equals(EntityName, StringComparison.InvariantCultureIgnoreCase));
        }

        /// <summary>Creates entity (not supported for read-only APIs)</summary>
        public virtual bool CreateEntityAs(EntityStructure entity)
        {
            throw new NotSupportedException("Entity creation not supported for Web API data sources");
        }

        /// <summary>Executes SQL (not applicable for REST APIs)</summary>
        public virtual IErrorsInfo ExecuteSql(string sql)
        {
            throw new NotSupportedException("SQL execution not supported for Web API data sources");
        }

        /// <summary>Gets child tables (relationships not typical in REST APIs)</summary>
        public virtual List<ChildRelation> GetChildTablesList(string tablename, string SchemaName, string Filterparamters)
        {
            return new List<ChildRelation>(); // REST APIs typically don't have traditional relationships
        }

        /// <summary>Gets child tables from custom query</summary>
        public virtual DataSet GetChildTablesListFromCustomQuery(string tablename, string customquery)
        {
            return new DataSet(); // Not applicable for REST APIs
        }

        /// <summary>Gets data reader (not applicable for REST APIs)</summary>
        public virtual IDataReader GetDataReader(string querystring)
        {
            throw new NotSupportedException("DataReader not supported for Web API data sources");
        }

        /// <summary>Gets list of available entities/endpoints</summary>
        public virtual List<string> GetEntitesList()
        {
            ErrorObject.Flag = Errors.Ok;
            try
            {
                var cacheKey = GenerateCacheKey("EntitiesList");
                var cached = GetFromCache<List<string>>(cacheKey);
                if (cached != null) return cached;

                var entities = Dataconnection.ConnectionProp.Entities.Select(x => x.EntityName).ToList();
                SetCache(cacheKey, entities);
                
                return entities;
            }
            catch (Exception ex)
            {
                DMEEditor.AddLogMessage("Fail", $"Failed to retrieve entities list for {DatasourceName} ({ex.Message})", 
                    DateTime.Now, 0, DatasourceName, Errors.Failed);
                return EntitiesNames ?? new List<string>();
            }
        }

        /// <summary>Gets entity data with filters</summary>
        public virtual IBindingList GetEntity(string EntityName, List<AppFilter> filter)
        {
            return GetEntityAsync(EntityName, filter).Result;
        }

        /// <summary>Gets entity data with pagination</summary>
        public virtual PagedResult GetEntity(string EntityName, List<AppFilter> filter, int pageNumber, int pageSize)
        {
            try
            {
                var entity = GetEntityStructure(EntityName, false);
                if (entity == null)
                {
                    throw new ArgumentException($"Entity '{EntityName}' not found");
                }

                return ExecuteWithRetryAsync(async () =>
                {
                    var endpoint = BuildEntityEndpoint(entity, filter, pageNumber, pageSize);
                    var request = await PrepareRequestAsync(endpoint, HttpMethod.Get);
                    var response = await client.SendAsync(request);
                    response.EnsureSuccessStatusCode();

                    var content = await response.Content.ReadAsStringAsync();
                    var data = ProcessApiResponse(content, entity);

                    return new PagedResult
                    {
                        Data = data,
                        PageNumber = pageNumber,
                        PageSize = pageSize,
                        TotalRecords = GetTotalRecordsFromResponse(content, response.Headers)
                    };
                }, $"GetEntity-{EntityName}").Result;
            }
            catch (Exception ex)
            {
                DMEEditor.AddLogMessage("Error", $"Failed to get entity {EntityName}: {ex.Message}", 
                    DateTime.Now, 0, DatasourceName, Errors.Failed);
                return new PagedResult { Data = new List<object>() };
            }
        }

        /// <summary>Runs custom query</summary>
        public virtual IBindingList RunQuery(string qrystr)
        {
            return GetEntityAsync("query", new List<AppFilter>()).Result;
        }

        /// <summary>Gets entity foreign keys (not applicable for REST APIs)</summary>
        public virtual List<RelationShipKeys> GetEntityforeignkeys(string entityname, string SchemaName)
        {
            return new List<RelationShipKeys>(); // REST APIs typically don't have foreign keys
        }

        /// <summary>Gets entity structure definition</summary>
        public EntityStructure GetEntityStructure(string EntityName, bool refresh)
        {
            var cacheKey = GenerateCacheKey("EntityStructure", EntityName);
            if (!refresh)
            {
                var cached = GetFromCache<EntityStructure>(cacheKey);
                if (cached != null) return cached;
            }

            var entity = Dataconnection.ConnectionProp.Entities
                .FirstOrDefault(o => o.EntityName.Equals(EntityName, StringComparison.InvariantCultureIgnoreCase));
                
            if (entity != null && refresh)
            {
                SetCache(cacheKey, entity);
            }
                
            return entity;
        }

        /// <summary>Gets entity structure from existing structure</summary>
        public EntityStructure GetEntityStructure(EntityStructure fnd, bool refresh = false)
        {
            return GetEntityStructure(fnd.EntityName, refresh);
        }

        /// <summary>Gets dynamic type for entity</summary>
        public Type GetEntityType(string EntityName)
        {
            var structure = GetEntityStructure(EntityName, false);
            if (structure != null)
            {
                DMTypeBuilder.CreateNewObject(DMEEditor, EntityName, EntityName, structure.Fields);
                return DMTypeBuilder.MyType;
            }
            return typeof(object);
        }

        #endregion

        #region Transaction Support (Limited for REST APIs)

        /// <summary>Begins transaction (limited support for REST APIs)</summary>
        public virtual IErrorsInfo BeginTransaction(PassedArgs args)
        {
            ErrorObject.Flag = Errors.Ok;
            try
            {
                // REST APIs typically don't support traditional transactions
                // This could be used to begin a batch operation or session
                DMEEditor.AddLogMessage("Info", "Transaction support limited for Web API", DateTime.Now, 0, null, Errors.Ok);
            }
            catch (Exception ex)
            {
                DMEEditor.AddLogMessage("Error", $"Error in Begin Transaction {ex.Message}", DateTime.Now, 0, null, Errors.Failed);
            }
            return ErrorObject;
        }

        /// <summary>Ends transaction</summary>
        public virtual IErrorsInfo EndTransaction(PassedArgs args)
        {
            ErrorObject.Flag = Errors.Ok;
            try
            {
                // Placeholder for ending batch operations
            }
            catch (Exception ex)
            {
                DMEEditor.AddLogMessage("Error", $"Error in End Transaction {ex.Message}", DateTime.Now, 0, null, Errors.Failed);
            }
            return ErrorObject;
        }

        /// <summary>Commits transaction</summary>
        public virtual IErrorsInfo Commit(PassedArgs args)
        {
            ErrorObject.Flag = Errors.Ok;
            try
            {
                // Placeholder for committing batch operations
            }
            catch (Exception ex)
            {
                DMEEditor.AddLogMessage("Error", $"Error in Commit Transaction {ex.Message}", DateTime.Now, 0, null, Errors.Failed);
            }
            return ErrorObject;
        }

        #endregion
        public virtual IErrorsInfo UpdateEntities(string EntityName, object UploadData, IProgress<PassedArgs> progress)
        {
            throw new NotImplementedException();
        }
        public virtual IErrorsInfo UpdateEntity(string EntityName, object UploadDataRow)
        {


            throw new NotImplementedException();
        }
        public IErrorsInfo DeleteEntity(string EntityName, object DeletedDataRow)
        {
            throw new NotImplementedException();
        }

        
        public IErrorsInfo RunScript(ETLScriptDet dDLScripts)
        {
            throw new NotImplementedException();
        }

        public IErrorsInfo CreateEntities(List<EntityStructure> entities)
        {
            throw new NotImplementedException();
        }
        public List<ETLScriptDet> GetCreateEntityScript(List<EntityStructure> entities = null)
        {
            throw new NotImplementedException();
        }

        public IErrorsInfo InsertEntity(string EntityName, object InsertedData)
        {
            throw new NotImplementedException();
        }

        public virtual async Task<IBindingList> GetEntityAsync(string EntityName, List<AppFilter> Filter)
        {
            var request = new HttpRequestMessage();
            client = new HttpClient();
            string filterstr="";
            client.BaseAddress = new Uri(Dataconnection.ConnectionProp.Url);

            EntityStructure ent = Dataconnection.ConnectionProp.Entities.Where(o => o.EntityName == EntityName).FirstOrDefault();
            if (!string.IsNullOrEmpty(Dataconnection.ConnectionProp.ApiKey))
            {
                Dataconnection.ConnectionProp.Url = Dataconnection.ConnectionProp.Url.Replace("@apikey", Dataconnection.ConnectionProp.ApiKey);
            }
            if (!string.IsNullOrEmpty(filterstr))
            {
                filterstr = filterstr.Replace("@apikey", Dataconnection.ConnectionProp.ApiKey);
            }
           
            request.Method = HttpMethod.Get;
            request.RequestUri = new Uri(Dataconnection.ConnectionProp.Url + "/" + filterstr);
            foreach (WebApiHeader item in Dataconnection.ConnectionProp.Headers)
            {
                request.Headers.Add(item.Headername, item.Headervalue);
            }

            //string retval = SendAsync(request).Result;

            using (var response = await client.SendAsync(request))
            {
                //    response.EnsureSuccessStatusCode();
                var body = await response.Content.ReadAsStringAsync();

                dynamic x = DMEEditor.ConfigEditor.JsonLoader.DeserializeObjectString<dynamic>(body);
                return x;
            }


        }
        #region "dispose"
        private bool disposedValue;
        protected virtual void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    // TODO: dispose managed state (managed objects)
                }

                // TODO: free unmanaged resources (unmanaged objects) and override finalizer
                // TODO: set large fields to null
                disposedValue = true;
            }
        }

        // // TODO: override finalizer only if 'Dispose(bool disposing)' has code to free unmanaged resources
        // ~RDBSource()
        // {
        //     // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
        //     Dispose(disposing: false);
        // }

        public void Dispose()
        {
            // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
        #endregion
    }
}