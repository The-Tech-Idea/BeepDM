<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Best Practices - Beep Editor Documentation</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
            padding: 2rem 0;
            margin-bottom: 2rem;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .content-section {
            background: white;
            border-radius: 10px;
            padding: 2rem;
            margin: 2rem 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .content-section h2 {
            color: #333;
            margin-bottom: 1rem;
            border-bottom: 2px solid #667eea;
            padding-bottom: 0.5rem;
        }

        .content-section h3 {
            color: #555;
            margin: 1.5rem 0 1rem 0;
        }

        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 5px;
            overflow-x: auto;
            margin: 1rem 0;
        }

        .nav-breadcrumb {
            background: white;
            padding: 1rem;
            border-radius: 5px;
            margin-bottom: 1rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .nav-breadcrumb a {
            color: #667eea;
            text-decoration: none;
        }

        .nav-breadcrumb a:hover {
            text-decoration: underline;
        }

        .warning-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 1rem;
            border-radius: 5px;
            margin: 1rem 0;
        }

        .info-box {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
            padding: 1rem;
            border-radius: 5px;
            margin: 1rem 0;
        }

        .success-box {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 1rem;
            border-radius: 5px;
            margin: 1rem 0;
        }

        .danger-box {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 1rem;
            border-radius: 5px;
            margin: 1rem 0;
        }

        .best-practice-item {
            background: #f8f9fa;
            border-left: 4px solid #28a745;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 5px 5px 0;
        }

        .anti-pattern-item {
            background: #f8f9fa;
            border-left: 4px solid #dc3545;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 5px 5px 0;
        }

        ul {
            margin-left: 2rem;
        }

        li {
            margin: 0.5rem 0;
        }

        .sidebar {
            position: fixed;
            left: -350px;
            top: 0;
            width: 350px;
            height: 100vh;
            background: rgba(45, 55, 72, 0.95);
            color: white;
            padding: 2rem;
            transition: left 0.3s ease;
            z-index: 1000;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar.open {
            left: 0;
        }

        .sidebar h3 {
            margin-bottom: 1.5rem;
            color: #f7fafc;
            border-bottom: 2px solid #667eea;
            padding-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .sidebar ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .sidebar ul li {
            margin: 0.5rem 0;
        }

        .sidebar ul li a {
            color: #cbd5e0;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .sidebar ul li a:hover,
        .sidebar ul li a.active {
            background: #667eea;
            color: white;
        }

        .sidebar ul li a i {
            width: 16px;
            text-align: center;
        }

        .menu-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 0.75rem;
            border-radius: 8px;
            cursor: pointer;
            z-index: 1001;
            font-size: 1.2rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .menu-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <button class="menu-toggle" onclick="toggleSidebar()">
        <i class="fas fa-bars"></i>
    </button>
    
    <div class="overlay" onclick="closeSidebar()"></div>
    
    <nav class="sidebar">
        <h3><i class="fas fa-book"></i> Documentation</h3>
        <ul>
            <li><a href="index.html"><i class="fas fa-home"></i> Home</a></li>
            <li><a href="registerbeep.html"><i class="fas fa-user-plus"></i> RegisterBeep</a></li>
            <li><a href="data-management-examples.html"><i class="fas fa-database"></i> Data Management Examples</a></li>
            <li><a href="unitofwork.html"><i class="fas fa-layer-group"></i> UnitOfWork</a></li>
            <li><a href="unitofwork-deep-dive.html"><i class="fas fa-search"></i> UnitOfWork Deep Dive</a></li>
            <li><a href="multidatasource-unitofwork.html"><i class="fas fa-project-diagram"></i> MultiDataSource UnitOfWork</a></li>
            <li><a href="unitofwork-factory.html"><i class="fas fa-industry"></i> UnitOfWork Factory</a></li>
            <li><a href="unitofwork-wrapper.html"><i class="fas fa-box"></i> UnitOfWork Wrapper</a></li>
            <li><a href="api-reference.html"><i class="fas fa-code"></i> API Reference</a></li>
            <li><a href="examples.html"><i class="fas fa-file-code"></i> Code Examples</a></li>
            <li><a href="best-practices.html" class="active"><i class="fas fa-star"></i> Best Practices</a></li>
        </ul>
    </nav>

    <div class="container">
        <div class="nav-breadcrumb">
            <a href="index.html">Home</a> > Best Practices
        </div>

        <header>
            <h1>Best Practices</h1>
            <p>Guidelines for effective use of Beep Editor components</p>
        </header>

        <div class="content-section">
            <h2>General Principles</h2>
            
            <div class="best-practice-item">
                <h3>?? Follow SOLID Principles</h3>
                <p>Design your data access layer following SOLID principles. Each UnitOfWork should have a single responsibility, and dependencies should be injected rather than created directly.</p>
            </div>

            <div class="best-practice-item">
                <h3>?? Always Use Using Statements</h3>
                <p>UnitOfWork implements IDisposable. Always use using statements or explicitly call Dispose() to ensure proper resource cleanup.</p>
                <div class="code-block">
<pre><code class="language-csharp">// Good
using (var uow = new UnitofWork&lt;Customer&gt;(dmeEditor, "SqlServer", "Customers", "CustomerID"))
{
    // Work with UnitOfWork
    await uow.CommitAsync();
}

// Also Good
var uow = new UnitofWork&lt;Customer&gt;(dmeEditor, "SqlServer", "Customers", "CustomerID");
try
{
    // Work with UnitOfWork
    await uow.CommitAsync();
}
finally
{
    uow.Dispose();
}</code></pre>
                </div>
            </div>

            <div class="best-practice-item">
                <h3>? Use Async/Await Consistently</h3>
                <p>Always use async versions of methods for database operations to avoid blocking the UI thread.</p>
                <div class="code-block">
<pre><code class="language-csharp">// Good
await customerUoW.InsertAsync(newCustomer);
await customerUoW.CommitAsync();

// Bad - Don't block async calls
customerUoW.InsertAsync(newCustomer).Wait();
customerUoW.CommitAsync().Result;</code></pre>
                </div>
            </div>
        </div>

        <div class="content-section">
            <h2>UnitOfWork Best Practices</h2>

            <div class="best-practice-item">
                <h3>?? Initialize Early, Use Throughout</h3>
                <p>Initialize UnitOfWork instances early in your application lifecycle and reuse them throughout the session.</p>
                <div class="code-block">
<pre><code class="language-csharp">public class CustomerService
{
    private readonly UnitofWork&lt;Customer&gt; _customerUoW;
    
    public CustomerService(IDMEEditor dmeEditor)
    {
        _customerUoW = new UnitofWork&lt;Customer&gt;(dmeEditor, "SqlServer", "Customers", "CustomerID");
        
        // Setup event handlers once
        _customerUoW.PreInsert += ValidateCustomer;
        _customerUoW.PostEdit += LogChanges;
    }
    
    // Use throughout the service...
}</code></pre>
                </div>
            </div>

            <div class="best-practice-item">
                <h3>?? Implement Proper Validation</h3>
                <p>Use event handlers to implement validation logic at appropriate lifecycle points.</p>
                <div class="code-block">
<pre><code class="language-csharp">private void ValidateCustomer(object sender, UnitofWorkParams args)
{
    var customer = (Customer)sender;
    
    if (string.IsNullOrWhiteSpace(customer.Email))
    {
        args.Cancel = true;
        throw new ValidationException("Email is required");
    }
    
    if (!IsValidEmail(customer.Email))
    {
        args.Cancel = true;
        throw new ValidationException("Invalid email format");
    }
}</code></pre>
                </div>
            </div>

            <div class="best-practice-item">
                <h3>?? Check IsDirty Before Operations</h3>
                <p>Always check IsDirty before committing or closing to avoid data loss.</p>
                <div class="code-block">
<pre><code class="language-csharp">public async Task&lt;bool&gt; CloseFormAsync()
{
    if (_customerUoW.IsDirty)
    {
        var result = MessageBox.Show("Save changes?", "Unsaved Changes", MessageBoxButtons.YesNoCancel);
        
        switch (result)
        {
            case DialogResult.Yes:
                var commitResult = await _customerUoW.CommitAsync();
                return commitResult.Flag == Errors.Ok;
            case DialogResult.No:
                await _customerUoW.Rollback();
                return true;
            case DialogResult.Cancel:
                return false;
        }
    }
    
    return true;
}</code></pre>
                </div>
            </div>

            <div class="best-practice-item">
                <h3>?? Handle Rollback Scenarios</h3>
                <p>Implement proper rollback handling for error scenarios.</p>
                <div class="code-block">
<pre><code class="language-csharp">public async Task&lt;bool&gt; ProcessBatchAsync(List&lt;Customer&gt; customers)
{
    try
    {
        foreach (var customer in customers)
        {
            await _customerUoW.InsertAsync(customer);
        }
        
        var result = await _customerUoW.CommitAsync();
        if (result.Flag != Errors.Ok)
        {
            await _customerUoW.Rollback();
            return false;
        }
        
        return true;
    }
    catch (Exception ex)
    {
        await _customerUoW.Rollback();
        Logger.LogError(ex, "Batch processing failed");
        return false;
    }
}</code></pre>
                </div>
            </div>
        </div>

        <div class="content-section">
            <h2>MultiDataSourceUnitOfWork Best Practices</h2>

            <div class="best-practice-item">
                <h3>??? Setup Relationships Early</h3>
                <p>Define all relationships before starting data operations to ensure proper coordination.</p>
                <div class="code-block">
<pre><code class="language-csharp">private async Task InitializeMultiUoWAsync()
{
    _multiUoW = new MultiDataSourceUnitOfWork(_dmeEditor);
    
    // Add all entity types first
    await _multiUoW.AddUnitOfWorkAsync&lt;Customer&gt;("SqlServer", "Customers", "CustomerID");
    await _multiUoW.AddUnitOfWorkAsync&lt;Order&gt;("MongoDB", "Orders", "OrderID");
    await _multiUoW.AddUnitOfWorkAsync&lt;Address&gt;("SqlServer", "Addresses", "AddressID");
    
    // Then define relationships
    _multiUoW.AddRelationship("Customer", "Order", "CustomerID", "CustomerID");
    _multiUoW.AddRelationship("Customer", "Address", "CustomerID", "CustomerID", 
                             RelationshipBehavior.CascadeDelete);
    
    // Finally, setup event handlers
    _multiUoW.ChildDataChanged += OnChildDataChanged;
}</code></pre>
                </div>
            </div>

            <div class="best-practice-item">
                <h3>?? Use Events for UI Updates</h3>
                <p>Subscribe to ChildDataChanged events to keep UI synchronized with data changes.</p>
                <div class="code-block">
<pre><code class="language-csharp">private async void OnChildDataChanged(object sender, ChildDataChangedEventArgs args)
{
    // Update UI based on which child data changed
    switch (args.ChildEntityName)
    {
        case "Order":
            await RefreshOrdersGrid();
            break;
        case "Address":
            await RefreshAddressControls();
            break;
    }
}</code></pre>
                </div>
            </div>

            <div class="best-practice-item">
                <h3>?? Choose Appropriate Relationship Behaviors</h3>
                <p>Select relationship behaviors based on business requirements, not technical convenience.</p>
                <div class="code-block">
<pre><code class="language-csharp">// For optional relationships
_multiUoW.AddRelationship("Customer", "Note", "CustomerID", "CustomerID", 
                         RelationshipBehavior.SetNull, false);

// For required audit trails
_multiUoW.AddRelationship("Order", "OrderHistory", "OrderID", "OrderID", 
                         RelationshipBehavior.Restrict, true);

// For true parent-child relationships
_multiUoW.AddRelationship("Invoice", "InvoiceLine", "InvoiceID", "InvoiceID", 
                         RelationshipBehavior.CascadeDelete, true);</code></pre>
                </div>
            </div>
        </div>

        <div class="content-section">
            <h2>Performance Best Practices</h2>

            <div class="best-practice-item">
                <h3>?? Use Filtering at Database Level</h3>
                <p>Apply filters at the database level rather than in memory to improve performance.</p>
                <div class="code-block">
<pre><code class="language-csharp">// Good - Database filtering
var filters = new List&lt;AppFilter&gt;
{
    new AppFilter { FieldName = "Status", Operator = "=", FilterValue = "Active" },
    new AppFilter { FieldName = "CreatedDate", Operator = "&gt;", FilterValue = DateTime.Now.AddDays(-30) }
};
var customers = await _customerUoW.Get(filters);

// Bad - In-memory filtering
var allCustomers = await _customerUoW.Get();
var filteredCustomers = allCustomers.Where(c =&gt; c.Status == "Active" && 
                                          c.CreatedDate &gt; DateTime.Now.AddDays(-30));</code></pre>
                </div>
            </div>

            <div class="best-practice-item">
                <h3>?? Batch Operations When Possible</h3>
                <p>For large datasets, process data in batches to avoid memory issues.</p>
                <div class="code-block">
<pre><code class="language-csharp">public async Task ProcessLargeDatasetAsync(IEnumerable&lt;ImportData&gt; data)
{
    const int batchSize = 1000;
    var batch = new List&lt;Customer&gt;();
    
    foreach (var item in data)
    {
        batch.Add(CreateCustomerFromImport(item));
        
        if (batch.Count >= batchSize)
        {
            await ProcessBatch(batch);
            batch.Clear();
        }
    }
    
    // Process remaining items
    if (batch.Any())
    {
        await ProcessBatch(batch);
    }
}</code></pre>
                </div>
            </div>

            <div class="best-practice-item">
                <h3>?? Use Progress Reporting for Long Operations</h3>
                <p>Implement progress reporting for operations that might take significant time.</p>
                <div class="code-block">
<pre><code class="language-csharp">var progress = new Progress&lt;PassedArgs&gt;(args =&gt; 
{
    UpdateProgressBar(args.ParameterInt1, args.ParameterString1);
});

var cancellationToken = new CancellationTokenSource();

var result = await _customerUoW.Commit(progress, cancellationToken.Token);</code></pre>
                </div>
            </div>
        </div>

        <div class="content-section">
            <h2>Error Handling Best Practices</h2>

            <div class="best-practice-item">
                <h3>??? Implement Comprehensive Error Handling</h3>
                <p>Handle different types of errors appropriately and provide meaningful feedback.</p>
                <div class="code-block">
<pre><code class="language-csharp">public async Task&lt;ServiceResult&gt; CreateCustomerAsync(CustomerData data)
{
    try
    {
        var customer = MapToEntity(data);
        
        await _customerUoW.InsertAsync(customer);
        var result = await _customerUoW.CommitAsync();
        
        if (result.Flag == Errors.Ok)
        {
            return ServiceResult.Success(customer.CustomerID);
        }
        else
        {
            return ServiceResult.Failure($"Database error: {result.Message}");
        }
    }
    catch (ValidationException ex)
    {
        return ServiceResult.ValidationError(ex.Message);
    }
    catch (SqlException ex) when (ex.Number == 2) // Timeout
    {
        return ServiceResult.Failure("Database timeout. Please try again.");
    }
    catch (SqlException ex) when (ex.Number == 2627) // Duplicate key
    {
        return ServiceResult.Failure("Customer with this ID already exists.");
    }
    catch (Exception ex)
    {
        Logger.LogError(ex, "Unexpected error creating customer");
        return ServiceResult.Failure("An unexpected error occurred.");
    }
}</code></pre>
                </div>
            </div>

            <div class="best-practice-item">
                <h3>?? Log Important Operations</h3>
                <p>Enable logging for audit trails and debugging purposes.</p>
                <div class="code-block">
<pre><code class="language-csharp">// Enable logging
_customerUoW.IsLogging = true;

// Periodically save logs
await Task.Run(() =&gt; 
{
    var logPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), 
                              "MyApp", "Logs", $"customer-changes-{DateTime.Now:yyyyMMdd}.json");
    _customerUoW.SaveLog(logPath);
});</code></pre>
                </div>
            </div>
        </div>

        <div class="content-section">
            <h2>Testing Best Practices</h2>

            <div class="best-practice-item">
                <h3>?? Use List Mode for Unit Testing</h3>
                <p>Use list mode for unit testing to avoid database dependencies.</p>
                <div class="code-block">
<pre><code class="language-csharp">[Test]
public async Task Should_Track_Changes_Correctly()
{
    // Arrange
    var testData = new ObservableBindingList&lt;Customer&gt;();
    var uow = new UnitofWork&lt;Customer&gt;(mockDMEEditor, true, testData, "CustomerID");
    
    // Act
    uow.New();
    var customer = uow.CurrentItem;
    customer.Name = "Test Customer";
    
    // Assert
    Assert.IsTrue(uow.IsDirty);
    Assert.AreEqual(1, uow.GetAddedEntities().Count());
}</code></pre>
                </div>
            </div>

            <div class="best-practice-item">
                <h3>?? Mock Dependencies</h3>
                <p>Mock IDMEEditor and IDataSource for isolated unit testing.</p>
                <div class="code-block">
<pre><code class="language-csharp">[SetUp]
public void Setup()
{
    _mockDMEEditor = new Mock&lt;IDMEEditor&gt;();
    _mockDataSource = new Mock&lt;IDataSource&gt;();
    
    _mockDMEEditor.Setup(x =&gt; x.GetDataSource(It.IsAny&lt;string&gt;()))
                  .Returns(_mockDataSource.Object);
    
    _mockDataSource.Setup(x =&gt; x.GetEntity(It.IsAny&lt;string&gt;(), It.IsAny&lt;List&lt;AppFilter&gt;&gt;()))
                   .Returns(new List&lt;Customer&gt;());
}</code></pre>
                </div>
            </div>
        </div>

        <div class="content-section">
            <h2>Security Best Practices</h2>

            <div class="best-practice-item">
                <h3>?? Validate Input Data</h3>
                <p>Always validate input data before processing to prevent injection attacks and data corruption.</p>
                <div class="code-block">
<pre><code class="language-csharp">private void ValidateCustomerInput(Customer customer)
{
    if (string.IsNullOrWhiteSpace(customer.Name))
        throw new ValidationException("Name is required");
    
    if (customer.Name.Length > 100)
        throw new ValidationException("Name cannot exceed 100 characters");
    
    if (!string.IsNullOrEmpty(customer.Email) && !IsValidEmail(customer.Email))
        throw new ValidationException("Invalid email format");
    
    // Sanitize input
    customer.Name = customer.Name.Trim();
    customer.Email = customer.Email?.Trim().ToLowerInvariant();
}</code></pre>
                </div>
            </div>

            <div class="best-practice-item">
                <h3>?? Implement Authorization Checks</h3>
                <p>Check user permissions before allowing data operations.</p>
                <div class="code-block">
<pre><code class="language-csharp">private void CheckPermissions(string operation, Customer customer)
{
    var currentUser = _securityService.GetCurrentUser();
    
    if (!currentUser.HasPermission($"Customer.{operation}"))
    {
        throw new UnauthorizedAccessException($"User not authorized for {operation}");
    }
    
    // Check record-level security
    if (operation == "Delete" && customer.CreatedBy != currentUser.UserId && 
        !currentUser.HasRole("Admin"))
    {
        throw new UnauthorizedAccessException("Can only delete own records");
    }
}</code></pre>
                </div>
            </div>
        </div>

        <div class="content-section">
            <h2>Common Anti-Patterns to Avoid</h2>

            <div class="anti-pattern-item">
                <h3>? Don't Create UnitOfWork in Loops</h3>
                <p>Creating new UnitOfWork instances in loops is inefficient and can cause resource issues.</p>
                <div class="code-block">
<pre><code class="language-csharp">// BAD - Don't do this
foreach (var customerData in importData)
{
    using (var uow = new UnitofWork&lt;Customer&gt;(...))  // Creates new connection each time
    {
        await uow.InsertAsync(CreateCustomer(customerData));
        await uow.CommitAsync();
    }
}

// GOOD - Reuse UnitOfWork
using (var uow = new UnitofWork&lt;Customer&gt;(...))
{
    foreach (var customerData in importData)
    {
        await uow.InsertAsync(CreateCustomer(customerData));
    }
    await uow.CommitAsync();  // Single commit
}</code></pre>
                </div>
            </div>

            <div class="anti-pattern-item">
                <h3>? Don't Ignore Event Cancellation</h3>
                <p>Always respect the Cancel flag in event handlers.</p>
                <div class="code-block">
<pre><code class="language-csharp">// BAD - Ignoring cancellation
private void OnPreInsert(object sender, UnitofWorkParams args)
{
    var customer = (Customer)sender;
    if (customer.Email == null)
    {
        args.Cancel = true;  // Set cancel but continue processing
        customer.Email = "unknown@example.com";  // This shouldn't happen
    }
}

// GOOD - Respect cancellation
private void OnPreInsert(object sender, UnitofWorkParams args)
{
    var customer = (Customer)sender;
    if (customer.Email == null)
    {
        args.Cancel = true;
        return;  // Stop processing
    }
}</code></pre>
                </div>
            </div>

            <div class="anti-pattern-item">
                <h3>? Don't Mix Synchronous and Asynchronous Calls</h3>
                <p>Mixing sync and async calls can lead to deadlocks and performance issues.</p>
                <div class="code-block">
<pre><code class="language-csharp">// BAD - Blocking async calls
public void ProcessCustomer(Customer customer)
{
    _customerUoW.InsertAsync(customer).Wait();  // Can cause deadlocks
    var result = _customerUoW.CommitAsync().Result;  // Can cause deadlocks
}

// GOOD - Async all the way
public async Task ProcessCustomerAsync(Customer customer)
{
    await _customerUoW.InsertAsync(customer);
    var result = await _customerUoW.CommitAsync();
}</code></pre>
                </div>
            </div>
        </div>

        <div class="content-section">
            <h2>Deployment and Production Checklist</h2>
            
            <ul class="checklist">
                <li>Configure appropriate connection timeouts for your environment</li>
                <li>Implement proper logging and monitoring</li>
                <li>Set up error alerting for critical operations</li>
                <li>Test rollback scenarios under load</li>
                <li>Verify that all UnitOfWork instances are properly disposed</li>
                <li>Configure appropriate batch sizes for your data volume</li>
                <li>Test with production-like data volumes</li>
                <li>Implement health checks for data source connections</li>
                <li>Set up backup and recovery procedures</li>
                <li>Document your relationship configurations</li>
                <li>Train support staff on common error scenarios</li>
                <li>Implement graceful degradation for data source failures</li>
            </ul>
        </div>

        <div class="info-box">
            <strong>Remember:</strong> These best practices are guidelines based on common scenarios. Always adapt them to your specific requirements and constraints. Regular code reviews and performance testing will help ensure your implementation remains optimal as your application evolves.
        </div>
    </div>

    <script>
        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.querySelector('.overlay');
            
            sidebar.classList.toggle('open');
            overlay.classList.toggle('active');
        }

        function closeSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.querySelector('.overlay');
            
            sidebar.classList.remove('open');
            overlay.classList.remove('active');
        }

        // Close sidebar when clicking on links
        document.querySelectorAll('.sidebar a').forEach(link => {
            link.addEventListener('click', closeSidebar);
        });

        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeSidebar();
            }
            if (e.key === 'm' && e.ctrlKey) {
                e.preventDefault();
                toggleSidebar();
            }
        });
    </script>
</body>
</html>